<?php

/**
 * Coconut plugin for Craft
 *
 * @author Yoannis Jamar
 * @copyright Copyright (c) 2020 Yoannis Jamar
 * @link https://github.com/yoannisj/
 * @package craft-coconut
 *
 */

namespace yoannisj\coconut\services;

use yii\base\InvalidArgumentException;

use Craft;
use craft\base\Component;
use craft\base\FsInterface;
use craft\elements\Asset;
use craft\helpers\ArrayHelper;
use craft\helpers\DateTimeHelper;
use yoannisj\coconut\Coconut;
use yoannisj\coconut\models\Output;
use yoannisj\coconut\models\Job;
use yoannisj\coconut\records\OutputRecord;
use yoannisj\coconut\events\OutputEvent;
use yoannisj\coconut\helpers\JobHelper;

/**
 * Service component class to work with Coconut Outputs
 */
class Outputs extends Component
{
    // =Static
    // =========================================================================

    /**
     * Name of event triggered before saving an Output in the database.
     *
     * @var string
     */
    const EVENT_BEFORE_SAVE_OUTPUT = 'beforeSaveOutput';

    /**
     * Name of event triggered after saving an Output in the database.
     *
     * @var string
     */
    const EVENT_AFTER_SAVE_OUTPUT = 'afterSaveOutput';

    /**
     * Name of event triggered when transcoding of a Coconut Output is completed.
     *
     * @var string
     */
    const EVENT_COMPLETE_OUTPUT = 'completeOutput';

    /**
     * Name of event triggered before deleting an Output.
     *
     * @var string
     */
    const EVENT_BEFORE_DELETE_OUTPUT = 'deleteOutput';

    /**
     * Name of event triggered after deleting an Output.
     *
     * @var string
     */
    const EVENT_AFTER_DELETE_OUTPUT = 'deleteOutput';

    // =Properties
    // =========================================================================

    // =Public Methods
    // =========================================================================

    /**
     * Returns Output with given ID
     *
     * @param int $id ID of output to retreive
     *
     * @return Output|null Output saved with given ID, or `null`
     */
    public function getOutputById( int $id ): ?Output
    {
        // @todo Memoize found output
        $record = OutputRecord::findOne($id);
        if (!$record) return null;

        $output = new Output();
        $output = JobHelper::populateOutputFromRecord($output, $record);

        return $output;
    }

    /**
     * Returns Output for given input and format(s)
     *
     * @param mixed $input Input for wich to return the outputs
     * @param string|array $format
     * @param bool $transcode Whether to transcode missing output with Coconut.co
     *
     * @return Output[]
     */
    // public function getOutputs(
    //     string|int|Asset|Input|null $input,
    //     array $outputs,
    //     bool $transcode = false
    // ): array
    // {
    //     $input = JobHelper::resolveInput($input);
    //     $outputs = JobHelper::resolveOutputs($outputs);

    //     $savedOutputs = $this->getOutputsForInput($input);
    // }

    /**
     * Returns all saved outputs for given transcoding job ID.
     *
     * @param int $jobId ID of transcoding Job for which to get Outputs
     *
     * @return Output[]
     */
    public function getOutputsByJobId( int $jobId ): array
    {
        // @todo Memoize found outputs

        $records = OutputRecord::findAll([ 'jobId' => $jobId ]);
        $outputs = [];

        foreach ($records as $record)
        {
            $output = new Output();
            JobHelper::populateOutputFromRecord($output, $record);

            $outputs[] = $output;
        }

        return $outputs;
    }

    /**
     * Returns all saved outputs for given tanscoding Job model.
     *
     * @param Job $job Transcoding Job for which to get Outputs
     *
     * @return Output[]
     */
    public function getOutputsForJob( Job $job ): array
    {
        return $this->getOutputsByJobId($job->id);
    }

    /**
     * Returns all Outputs saved for given Input.
     *
     * This includes Outputs generated by jobs that are currently running,
     * jobs that have completed, and also outputs that have failed.
     * Outputs that have been saved in the database but haven't yet been
     * submitted to the Coconut service for transcoding are left out.
     *
     * The $input argument can be any value understood by
     * [[JobHelper::resolveInput()]].
     *
     * @param mixed $input Input for which to get the saved outputs
     *
     * @return Output[]
     */
    public function getOutputsForInput(
        mixed $input
    ): array
    {
        // @todo Memoize found outputs

        $input = JobHelper::resolveInput($input);
        $jobs = Coconut::$plugin->getJobs()->getJobsForInput($input);

        $outputs = [];

        foreach ($jobs as $job)
        {
            // don't include outputs Coconut does not know about ;)
            if ($job->coconutId) {
                $outputs += $job->getOutputs();
            }
        }

        return $outputs;
    }

    /**
     * Saves given Output model in the database.
     *
     * @param Output $output Output model to save
     * @param bool $runValidation Whether to validate Output before saving it
     *
     * @return bool Whether $output was saved successfully
     */
    public function saveOutput(
        Output $output,
        bool $runValidation = true
    ): bool
    {
        $isNewOutput = !isset($output->id);

        if ($this->hasEventHandlers(self::EVENT_BEFORE_SAVE_OUTPUT))
        {
            $this->trigger(self::EVENT_BEFORE_SAVE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => $isNewOutput,
            ]));
        }

        if ($runValidation && !$output->validate()) {
            return false;
        }

        $wasCompleted = false;
        $record = null;

        if (!$isNewOutput)
        {
            // get existing record for this output
            $record = OutputRecord::findOne($output->id) ?: new OutputRecord();

            if ($record) { // check if it was already completed
                $wasCompleted = in_array($record['status'], Output::COMPLETED_STATUSES);
            }
        }

        // or get new record
        if (!$record) $record = new OutputRecord();

        // update the record attributes
        JobHelper::populateRecordFromOutput($record, $output);

        // and try saving new values in the database
        if (!$record->save()) return false;

        // update output model's attributes based on what's now saved in the database
        $output->id = $record->id;
        $output->dateCreated = DateTimeHelper::toDateTime($record->dateCreated);
        $output->dateUpdated = DateTimeHelper::toDateTime($record->dateUpdated);
        $output->uid = $record->uid;

        if ($this->hasEventHandlers(self::EVENT_AFTER_SAVE_OUTPUT))
        {
            $this->trigger(self::EVENT_AFTER_SAVE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => $isNewOutput,
            ]));
        }

        // trigger output completion event
        if (!$wasCompleted && $output->getIsCompleted()
            && $this->hasEventHandlers(self::EVENT_COMPLETE_OUTPUT))
        {
            $this->trigger(self::EVENT_COMPLETE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => $isNewOutput,
            ]));
        }

        return true;
    }

    /**
     * Updates a Coconut Output with given data, and saves it back
     * into the database.
     *
     * @param Output $output Coconut Output to update
     * @param array $data Output data to update the Output with
     * @param bool $runValidation Whether to validate the updated Output
     *
     * @return bool Whether the Output was updated and saved successfully
     *
     * @throws InvalidArgumentException If given $output is new (i.e. it already has an ID)
     * @throws InvalidArgumentException If 'type' in given $data is unkown
     * @throws InvalidArgumentException If 'key' in given $data does not match with $output
     */
    public function updateOutput(
        Output $output,
        array $data,
        bool $runValidation = true
    ): bool
    {
        if (!isset($output->id)) {
            throw new InvalidArgumentException("Can not update new output");
        }

        $dataType = ArrayHelper::getValue($data, 'type');
        if (!$dataType != 'video' && $dataType != 'image' && $dataType != 'httpstream')
        {
            throw new InvalidArgumentException(
                "Unkown output type");
        }

        $key = ArrayHelper::getValue($data, 'key');
        if ($key && $key != $output->key)
        {
            throw new InvalidArgumentException(
                "Output key does not correspond with given data");
        }

        JobHelper::populateJobOutput($output, $data);

        if (!$this->saveOutput($output, $runValidation)) {
            return false;
        }

        return true;
    }

    /**
     * Deletes given Output by removing it from the database, and deleting the
     * output file (if stored on a Volume).
     *
     * @param Output $output Coconut Output to delete
     *
     * @return bool Whether $output was deleted successfully
     */
    public function deleteOutput( Output $output ): bool
    {
        // we can not delete an output which has not been saved yet
        if (!$output->id) return false;

        $record = OutputRecord::findOne($output->id);
        if (!$record) return false;

        if ($this->hasEventHandlers(self::EVENT_BEFORE_DELETE_OUTPUT))
        {
            $this->trigger(self::EVENT_BEFORE_DELETE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => false,
            ]));
        }

        // delete output files from volume storages
        $job = $output->getJob();
        $storageVolume = $job->getStorage()->getVolume();

        if ($storageVolume)
        {
            $storageFs = $storageVolume->getFs();

            if ($output->url) {
                $storageFs->deleteFile($output->path);
            }

            if ($output->urls)
            {
                for ($i = 1; $i <= count($output->urls); $i++)
                {
                    $urlPath = sprintf($output->path, $i);
                    $storageFs->deleteFile($urlPath);
                }
            }
        }

        if ($record->delete())
        {
            // @todo Delete job when all its outputs were deleted?
            if ($this->hasEventHandlers(self::EVENT_AFTER_DELETE_OUTPUT))
            {
                $this->trigger(self::EVENT_AFTER_DELETE_OUTPUT, new OutputEvent([
                    'output' => $output,
                    'isNew' => false,
                ]));
            }

            return true;
        }

        return false;
    }

    /**
     * Deletes given list of Output models.
     *
     * @param Output[] $outputs Outputs to delete
     *
     * @return bool Whether *all* Outputs were deleted successfully
     */
    public function clearOutputs( array $outputs ): bool
    {
        $success = true;

        foreach ($outputs as $output)
        {
            // only delete finished outputs
            if (!$output->getIsCompleted()) continue;

            // @todo: check if job output has id before deleting it?
            // -> might change whether this is considered successfull or not
            if (!$this->deleteOutput($output))  {
                $success = false;
            }
        }

        return $success;
    }

    /**
     * Deletes all outputs for given transcoding Job.
     *
     * @param Job Transcoding Job for which to delete Outputs
     *
     * @return bool Whether *all** found Outputs were deleted successfully
     */
    public function clearOutputsForJob( Job $job ): bool
    {
        $outputs = $this->getOutputsForJob($job);
        return $this->clearOutputs($outputs);
    }

    /**
     * Deletes all outputs for given Input.
     *
     * The $input argument can be any value understood by
     * [[JobHelper::resolveInput()]].
     *
     * @param mixed $input The Input for which to delete all outputs
     *
     * @return bool Whether *all* found Outputs were deleted successfully
     */
    public function clearOutputsForInput( mixed $input ): bool
    {
        $outputs = $this->getOutputsForInput($input);
        return $this->deleteOutputs($outputs);
    }












    /**
     * Initializes outputs for given job
     */
    // public function initJobOutputs( Job $job )
    // {
    //     // delete existing job outputs (deletes output files)
    //     $this->clearJobOutputs($job);

    //     // initialize common attributes for new outputs
    //     $outputVolume = $job->getOutputVolumeModel();
    //     $newAttrs = [
    //         'sourceAssetId' => $job->getSourceAssetId(),
    //         'source' => $job->getSource(),
    //         'volumeId' => (int)$outputVolume->id,
    //         'inProgress' => !!($job->coconutId),
    //         'coconutJobId' => $job->coconutId,
    //     ];

    //     // create new output for all output urls defined by job
    //     $outputUrls = $job->getOutputUrls();
    //     $newOutputs = [];

    //     foreach ($outputUrls as $format => $url)
    //     {
    //         // normalize for formats which create multiple outputs
    //         if (!is_array($url)) $url = [ $url ];

    //         foreach ($url as $outputUrl)
    //         {
    //             $attrs = array_merge($newAttrs, [
    //                 'format' => $format,
    //                 'url' => $outputUrl,
    //             ]);

    //             $output = new Output();
    //             $output->setAttributes($attrs);

    //             $this->saveOutput($output); // gives the output an id
    //             $newOutputs[] = $output; // collect newly created outputs
    //         }
    //     }

    //     return $newOutputs;
    // }

    /**
     * Returns output model for given source video, and optionally for
     * matching criteria.
     *
     * @param Asset | string $source Source for which to get outputs
     * @param array $criteria Criteria against which returned outputs should match
     *
     * @return Output | null
     */

    public function getSourceOutputs( $source, array $criteria = [] )
    {
        $outputs = $this->getAllSourceOutputs($source);

        if (!empty($criteria)) {
            $outputs = ArrayHelper::whereMultiple($outputs, $criteria);
        }

        return $outputs;
    }

    /**
     * Returns all output models for given source video
     *
     * @param string | int | \craft\elements\Asset $source
     *
     * @return array
     */
    // public function getAllSourceOutputs( $source ): array
    // {
    //     $key = $source->id ?? (is_numeric($source) ? (int)$source : $source);

    //     if (!array_key_exists($key, $this->sourceOutputs))
    //     {
    //         $outputs = [];

    //         $criteria = $this->getSourceCriteria($source);
    //         $records = OutputRecord::find()
    //             ->where($criteria)
    //             ->all();

    //         foreach ($records as $record)
    //         {
    //             $output = new Output();
    //             JobHelper::populateOutputFromRecord($output, $record);

    //             $outputs[] = $output;
    //         }

    //         $this->sourceOutputs[$key] = $outputs;
    //     }

    //     return $this->sourceOutputs[$key];
    // }

    /**
     * @param string | int | \craft\elements\Asset $source
     * @param array $criteria
     *
     * @return bool
     */
    // public function clearSourceOutputs( $source, array $criteria = [] )
    // {
    //     $sourceCriteria = $this->getSourceCriteria($source);
    //     $criteria = array_merge($criteria, $sourceCriteria);

    //     return $this->clearOutputs($criteria);
    // }

    /**
     * Returns outputs for given source and formats
     *
     * @param string | \craft\elements\Asset $source
     * @param array $formats
     * @param bool $transcodeMissing
     */

    // public function getFormatOutputs( $source, array $formats = null, bool $transcodeMissing = false, bool $useQueue = null )
    // {
    //     // get source job and outputs
    //     $sourceJob = Coconut::$plugin->normalizeSourceJob($source, null, false);
    //     $sourceOutputs = $this->getSourceOutputs($source);

    //     // if no formats were specified, use configured formats
    //     if (empty($formats) && $sourceJob) {
    //         $formats = array_keys($sourceJob->getOutputs());
    //     }

    //     // select and index source outputs for formats
    //     $formatOutputs = ArrayHelper::whereMultiple($sourceOutputs, [ 'format' => $formats ]);
    //     $outputs = [];

    //     foreach ($formatOutputs as $output)
    //     {
    //         if (!array_key_exists($output->format, $outputs)) {
    //             $outputs[$output->format] = [];
    //         }

    //         $outputs[$output->format][] = $output;
    //     }

    //     if ($transcodeMissing)
    //     {
    //         // look for missing output formats
    //         $missingFormats = array_diff($formats, array_keys($outputs));

    //         if (!empty($missingFormats))
    //         {
    //             // limit job to missing formats only
    //             $job = $sourceJob->forFormats($missingFormats);

    //             // transcode missing output formats, and merge in resulting outputs
    //             $newOutputs = Coconut::$plugin->transcodeSource($source, $job, $useQueue);
    //             $newOutputs = ArrayHelper::index($newOutputs, null, 'format');

    //             $outputs = array_merge_recursive($outputs, $newOutputs);
    //         }
    //     }

    //     return $outputs;
    // }

    // =Protected Methods
    // =========================================================================

    /**
     * Returns criteria to query for outputs in the database
     *
     * @param \craft\elements\Asset | string $source
     * @param string $key
     *
     * @return array4
     * @throws \yii\base\InvalidArgumentException
     */
    // protected function getSourceCriteria( $source, $key = null ): array
    // {
    //     $criteria = [];

    //     if (is_numeric($source)) {
    //         $criteria['sourceAssetId'] = $source;
    //     } else if (is_string($source)) {
    //         $criteria['source'] = $source;
    //     } else if ($source instanceof Asset) {
    //         $criteria['sourceAssetId'] = $source->id;
    //     } else {
    //         throw new InvalidArgumentException('Argument `source` must be an Asset element, an asset id, or a video url.');
    //     }

    //     if ($key) {
    //         $criteria['key'] = $key;
    //     }

    //     return $criteria;
    // }
}
