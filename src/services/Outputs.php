<?php

/**
 * Coconut plugin for Craft
 *
 * @author Yoannis Jamar
 * @copyright Copyright (c) 2020 Yoannis Jamar
 * @link https://github.com/yoannisj/
 * @package craft-coconut
 *
 */

namespace yoannisj\coconut\services;

use yii\base\InvalidArgumentException;

use Craft;
use craft\base\Component;
use craft\helpers\ArrayHelper;
use craft\helpers\DateTimeHelper;

use yoannisj\coconut\Coconut;
use yoannisj\coconut\models\Output;
use yoannisj\coconut\models\Job;
use yoannisj\coconut\records\OutputRecord;
use yoannisj\coconut\events\OutputEvent;
use yoannisj\coconut\helpers\JobHelper;

/**
 * Service component class to work with Coconut Outputs
 */
class Outputs extends Component
{
    // =Static
    // =========================================================================

    /**
     * Name of event triggered before saving an Output in the database.
     *
     * @var string
     */
    const EVENT_BEFORE_SAVE_OUTPUT = 'beforeSaveOutput';

    /**
     * Name of event triggered after saving an Output in the database.
     *
     * @var string
     */
    const EVENT_AFTER_SAVE_OUTPUT = 'afterSaveOutput';

    /**
     * Name of event triggered when transcoding of a Coconut Output is completed.
     *
     * @var string
     */
    const EVENT_COMPLETE_OUTPUT = 'completeOutput';

    /**
     * Name of event triggered before deleting an Output.
     *
     * @var string
     */
    const EVENT_BEFORE_DELETE_OUTPUT = 'deleteOutput';

    /**
     * Name of event triggered after deleting an Output.
     *
     * @var string
     */
    const EVENT_AFTER_DELETE_OUTPUT = 'deleteOutput';

    // =Properties
    // =========================================================================

    // =Public Methods
    // =========================================================================

    /**
     * Returns Output with given ID
     *
     * @param int $id ID of output to retreive
     *
     * @return Output|null Output saved with given ID, or `null`
     */
    public function getOutputById( int $id ): ?Output
    {
        // @todo Memoize found output
        $record = OutputRecord::findOne($id);
        if (!$record) return null;

        $output = new Output();
        $output = JobHelper::populateOutputFromRecord($output, $record);

        return $output;
    }

    /**
     * Returns all saved outputs for given transcoding job ID.
     *
     * @param int $jobId ID of transcoding Job for which to get Outputs
     *
     * @return Output[]
     */
    public function getOutputsByJobId( int $jobId ): array
    {
        // @todo Memoize found outputs

        $records = OutputRecord::findAll([ 'jobId' => $jobId ]);
        $outputs = [];

        foreach ($records as $record)
        {
            $output = new Output();
            JobHelper::populateOutputFromRecord($output, $record);

            $outputs[] = $output;
        }

        return $outputs;
    }

    /**
     * Returns all saved outputs for given tanscoding Job model.
     *
     * @param Job $job Transcoding Job for which to get Outputs
     *
     * @return Output[]
     */
    public function getOutputsForJob( Job $job ): array
    {
        return $this->getOutputsByJobId($job->id);
    }

    /**
     * Returns all Outputs saved for given Input.
     *
     * This includes Outputs generated by jobs that are currently running,
     * jobs that have completed, and also outputs that have failed.
     * Outputs that have been saved in the database but haven't yet been
     * submitted to the Coconut service for transcoding are left out.
     *
     * The $input argument can be any value understood by
     * [[JobHelper::resolveInput()]].
     *
     * @param mixed $input Input for which to get the saved outputs
     *
     * @return Output[]
     */
    public function getOutputsForInput(
        mixed $input
    ): array
    {
        // @todo Memoize found outputs

        $input = JobHelper::resolveInput($input);
        $jobs = Coconut::$plugin->getJobs()->getJobsForInput($input);

        $outputs = [];

        foreach ($jobs as $job)
        {
            // don't include outputs Coconut does not know about ;)
            if ($job->coconutId) {
                $outputs += $job->getOutputs();
            }
        }

        return $outputs;
    }

    /**
     * Saves given Output model in the database.
     *
     * @param Output $output Output model to save
     * @param bool $runValidation Whether to validate Output before saving it
     *
     * @return bool Whether $output was saved successfully
     */
    public function saveOutput(
        Output $output,
        bool $runValidation = true
    ): bool
    {
        $isNewOutput = !isset($output->id);

        if ($this->hasEventHandlers(self::EVENT_BEFORE_SAVE_OUTPUT))
        {
            $this->trigger(self::EVENT_BEFORE_SAVE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => $isNewOutput,
            ]));
        }

        if ($runValidation && !$output->validate()) {
            return false;
        }

        $wasCompleted = false;
        $record = null;

        if (!$isNewOutput)
        {
            // get existing record for this output
            $record = OutputRecord::findOne($output->id) ?: new OutputRecord();

            if ($record) { // check if it was already completed
                $wasCompleted = in_array($record['status'], Output::COMPLETED_STATUSES);
            }
        }

        // or get new record
        if (!$record) $record = new OutputRecord();

        // update output URL once it is completed
        // @todo Conditionally rewrite output URLs in `Output::getUrl()` and `Output::getUrls()` getters
        $isCompleted = $output->getIsCompleted();
        if ($isCompleted && ($volume = $output->getJob()?->getStorage()?->getVolume())) {
            JobHelper::rewriteOutputUrls($output, $volume);
        }

        // update the record attributes
        JobHelper::populateRecordFromOutput($record, $output);

        // and try saving new values in the database
        if (!$record->save()) return false;

        // update output model's attributes based on what's now saved in the database
        $output->id = $record->id;
        $output->dateCreated = DateTimeHelper::toDateTime($record->dateCreated);
        $output->dateUpdated = DateTimeHelper::toDateTime($record->dateUpdated);
        $output->uid = $record->uid;

        if ($this->hasEventHandlers(self::EVENT_AFTER_SAVE_OUTPUT))
        {
            $this->trigger(self::EVENT_AFTER_SAVE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => $isNewOutput,
            ]));
        }

        // trigger output completion event
        if (!$wasCompleted && $isCompleted
            && $this->hasEventHandlers(self::EVENT_COMPLETE_OUTPUT))
        {
            $this->trigger(self::EVENT_COMPLETE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => $isNewOutput,
            ]));
        }

        return true;
    }

    /**
     * Updates a Coconut Output with given data, and saves it back
     * into the database.
     *
     * @param Output $output Coconut Output to update
     * @param array $data Output data to update the Output with
     * @param bool $runValidation Whether to validate the updated Output
     *
     * @return bool Whether the Output was updated and saved successfully
     *
     * @throws InvalidArgumentException If given $output is new (i.e. it already has an ID)
     * @throws InvalidArgumentException If 'type' in given $data is unkown
     * @throws InvalidArgumentException If 'key' in given $data does not match with $output
     */
    public function updateOutput(
        Output $output,
        array $data,
        bool $runValidation = true
    ): bool
    {
        if (!isset($output->id)) {
            throw new InvalidArgumentException("Can not update new output");
        }

        $dataType = ArrayHelper::getValue($data, 'type');
        if (!$dataType != 'video' && $dataType != 'image' && $dataType != 'httpstream')
        {
            throw new InvalidArgumentException(
                "Unkown output type");
        }

        $key = ArrayHelper::getValue($data, 'key');
        if ($key && $key != $output->key)
        {
            throw new InvalidArgumentException(
                "Output key does not correspond with given data");
        }

        JobHelper::populateJobOutput($output, $data);

        if (!$this->saveOutput($output, $runValidation)) {
            return false;
        }

        return true;
    }

    /**
     * Deletes given Output by removing it from the database, and deleting the
     * output file (if stored on a Volume).
     *
     * @param Output $output Coconut Output to delete
     *
     * @return bool Whether $output was deleted successfully
     */
    public function deleteOutput( Output $output ): bool
    {
        // we can not delete an output which has not been saved yet
        if (!$output->id) return false;

        $record = OutputRecord::findOne($output->id);
        if (!$record) return false;

        if ($this->hasEventHandlers(self::EVENT_BEFORE_DELETE_OUTPUT))
        {
            $this->trigger(self::EVENT_BEFORE_DELETE_OUTPUT, new OutputEvent([
                'output' => $output,
                'isNew' => false,
            ]));
        }

        // delete output files from volume storages
        $job = $output->getJob();
        $storageVolume = $job->getStorage()->getVolume();

        if ($storageVolume)
        {
            $storageFs = $storageVolume->getFs();

            if ($output->url) {
                $storageFs->deleteFile($output->path);
            }

            if ($output->urls)
            {
                for ($i = 1; $i <= count($output->urls); $i++)
                {
                    $urlPath = sprintf($output->path, $i);
                    $storageFs->deleteFile($urlPath);
                }
            }
        }

        if ($record->delete())
        {
            // @todo Delete job when all its outputs were deleted?
            if ($this->hasEventHandlers(self::EVENT_AFTER_DELETE_OUTPUT))
            {
                $this->trigger(self::EVENT_AFTER_DELETE_OUTPUT, new OutputEvent([
                    'output' => $output,
                    'isNew' => false,
                ]));
            }

            return true;
        }

        return false;
    }

    /**
     * Deletes given list of Output models.
     *
     * @param Output[] $outputs Outputs to delete
     *
     * @return bool Whether *all* Outputs were deleted successfully
     */
    public function deleteOutputs( array $outputs ): bool
    {
        $success = true;

        foreach ($outputs as $output)
        {
            // only delete finished outputs
            if (!$output->getIsCompleted()) continue;

            // @todo: check if job output has id before deleting it?
            // -> might change whether this is considered successfull or not
            if (!$this->deleteOutput($output))  {
                $success = false;
            }
        }

        return $success;
    }

    /**
     * Deletes all outputs for given transcoding Job.
     *
     * @param Job Transcoding Job for which to delete Outputs
     *
     * @return bool Whether *all** found Outputs were deleted successfully
     */
    public function clearOutputsForJob( Job $job ): bool
    {
        $outputs = $this->getOutputsForJob($job);
        return $this->deleteOutputs($outputs);
    }

    /**
     * Deletes all outputs for given Input.
     *
     * The $input argument can be any value understood by
     * [[JobHelper::resolveInput()]].
     *
     * @param mixed $input The Input for which to delete all outputs
     *
     * @return bool Whether *all* found Outputs were deleted successfully
     */
    public function clearOutputsForInput( mixed $input ): bool
    {
        $outputs = $this->getOutputsForInput($input);
        return $this->deleteOutputs($outputs);
    }

    // =Protected Methods
    // =========================================================================

}
